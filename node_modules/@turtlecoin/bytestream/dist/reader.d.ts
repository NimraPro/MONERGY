/// <reference types="node" />
import { Writer } from './writer';
import * as BigInteger from 'big-integer';
import { Writable } from 'stream';
/**
 * Allows for easy reading of blob encoded data
 * @noInehritDoc
 */
export declare class Reader extends Writable {
    private m_current_offset;
    private m_buffer;
    /**
     * Constructs a new Reader instance
     * @param blob either another copy of a reader, writer, a Buffer, or a hexadecimal string representation of the data
     * @param encoding the encoding to use for the resulting string
     */
    constructor(blob?: Reader | Writer | Buffer | string, encoding?: BufferEncoding);
    /**
     * @returns the entire reader buffer
     */
    get buffer(): Buffer;
    /**
     * @returns the length of the blob in bytes
     */
    get length(): number;
    /**
     * @returns the current offset of the read buffer
     */
    get offset(): number;
    /**
     * @returns the number of bytes remaining in the stream that have not been read
     */
    get unreadBytes(): number;
    /**
     * @returns the subset of the buffer that has not been read yet
     */
    get unreadBuffer(): Buffer;
    /**
     * Extends the Stream.Writable interface such that we can be piped to
     * @param chunk
     * @param encoding
     * @param callback
     * @ignore
     */
    _write(chunk: Buffer | Uint8Array | string, encoding: BufferEncoding, callback: () => void): void;
    /**
     * Appends the data given to the end of the current buffer of the instance of the reader
     * @param blob either another copy of a reader, writer, a Buffer, or a hexadecimal string representation of the data
     * @param encoding the string encoding used
     */
    append(blob: Reader | Writer | Buffer | Uint8Array | string, encoding?: BufferEncoding): void;
    /**
     * Reads the supplied number of bytes
     * @param [count=1] the number of bytes to read
     * @returns a buffer containing the requested number of bytes
     */
    bytes(count?: number): Buffer;
    /**
     * Compacts the current reader buffer by trimming data before the current offset, or
     * if specified, the given offset and re-setting the current reading offset to 0
     * @param offset the offset to compact from
     */
    compact(offset?: number): void;
    /**
     * Reads the next hash of the given length from the stream and returns the value in hexadecimal notation
     * @param length the length of the hash in bytes
     * @param encoding the encoding to use for the resulting string
     * @returns the hash as a string
     */
    hash(length?: number, encoding?: BufferEncoding): string;
    /**
     * Reads the next supplied number of bytes and returns the result in hexadecimal notation
     * @param [count=1] the number of bytes to read
     * @param encoding the encoding to use for the resulting string
     * @returns a string containing the bytes in hexadecimal
     */
    hex(count?: number, encoding?: BufferEncoding): string;
    /**
     * Reads the number of bits as a signed integer
     * @param bits the number of bits to read
     * @param [be] whether to use big endian
     * @returns the value read
     */
    int_t(bits: number, be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a int8_t
     * @returns the value
     */
    int8_t(): BigInteger.BigInteger;
    /**
     * Reads a int16_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    int16_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a int32_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    int32_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Resets the reader offset to the given offset of the buffer
     * @param offset the offset to reset the reader to
     */
    reset(offset?: number): void;
    /**
     * Skips the specified number of bytes in the stream
     * @param [count=1] the number of bytes to skip
     */
    skip(count?: number): void;
    /**
     * Reads the next Date from the stream
     * @param [be] whether to use big endian
     */
    time_t(be?: boolean): Date;
    /**
     * Returns the current read buffer as a string
     * @param encoding
     */
    toString(encoding?: BufferEncoding): string;
    /**
     * Reads the number of bits as an unsigned integer
     * @param bits the number of bits to read
     * @param [be] whether to use big endian
     * @returns the value read
     */
    uint_t(bits: number, be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a uint8_t
     * @returns the value
     */
    uint8_t(): BigInteger.BigInteger;
    /**
     * Reads a uint16_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    uint16_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a uint32_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    uint32_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a uint64_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    uint64_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a uint128_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    uint128_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a uint256_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    uint256_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a uint512_t
     * @param [be] whether to use big endian
     * @returns the value
     */
    uint512_t(be?: boolean): BigInteger.BigInteger;
    /**
     * Reads a varint encoded value from the stream
     * @param [peek] if we are only peeking, we will not advance the reader cursor
     * @param [levin] whether we are reading a levin packed varint
     * @returns the value
     */
    varint(peek?: boolean, levin?: boolean): BigInteger.BigInteger;
}
